// controllers/store/dashboard.controller.js
import Order from "../../models/Order.model.js";
import Store from "../../models/Store.model.js";
import Product from "../../models/Product.model.js";
import ExcelJS from 'exceljs';

//! L·∫•y th·ªëng k√™ dashboard cho store manager
export const getStoreDashboard = async (req, res) => {
  try {
    console.log("‚úÖ Dashboard API called successfully");
    
    const managerId = req.user.userId || req.user._id;
    console.log("üîÑ Dashboard request from manager:", managerId);

    // T√¨m c·ª≠a h√†ng c·ªßa manager
    const store = await Store.findOne({ manager: managerId });
    console.log("üè™ Found store:", store?._id);
    
    if (!store) {
      return res.status(404).json({
        success: false,
        message: "Kh√¥ng t√¨m th·∫•y c·ª≠a h√†ng cho manager n√†y"
      });
    }

    const { period = "30d" } = req.query;
    const startDate = calculateStartDate(period);
    console.log("üìÖ Period:", period, "Start date:", startDate);

    // L·∫•y t·∫•t c·∫£ d·ªØ li·ªáu
    const orderStats = await getOrderStats(store._id, startDate);
    const revenueStats = await getRevenueStats(store._id, startDate);
    const customerStats = await getCustomerStats(store._id, startDate);
    const productStats = await getProductStats(store._id, startDate);
    const recentOrders = await getRecentOrders(store._id);

    console.log("üìä Final stats:", {
      orderStats,
      revenueStats, 
      customerStats,
      productStats
    });

    const dashboardData = {
      metrics: {
        // Order metrics
        totalOrders: orderStats.total,
        completedOrders: orderStats.completed,
        cancelledOrders: orderStats.cancelled,
        orderGrowth: 12.5, // T·∫°m th·ªùi fix c·ª©ng
        
        // Revenue metrics
        totalRevenue: revenueStats.total,
        averageOrderValue: orderStats.total > 0 ? revenueStats.total / orderStats.total : 0,
        revenueGrowth: 15.2, // T·∫°m th·ªùi fix c·ª©ng
        
        // Customer metrics
        newCustomers: customerStats.newCustomers,
        returningCustomers: customerStats.returningCustomers,
        customerGrowth: 8.3, // T·∫°m th·ªùi fix c·ª©ng
        
        // Product metrics
        productsSold: productStats.totalSold,
        topProducts: productStats.topProducts,
        productGrowth: 5.7 // T·∫°m th·ªùi fix c·ª©ng
      },
      charts: {
        dailyRevenue: revenueStats.daily,
        orderStatusBreakdown: orderStats.byStatus,
        paymentMethodBreakdown: revenueStats.byPaymentMethod
      },
      recentActivities: recentOrders,
      storeInfo: {
        storeName: store.storeName,
        storeCode: store.storeCode,
        totalProducts: await Product.countDocuments({ store: store._id, status: 'active' }) || 0
      }
    };

    res.status(200).json({
      success: true,
      message: "L·∫•y d·ªØ li·ªáu dashboard th√†nh c√¥ng",
      data: dashboardData
    });

  } catch (error) {
    console.error("‚ùå Error in dashboard API:", error);
    res.status(500).json({
      success: false,
      message: "L·ªói server khi l·∫•y d·ªØ li·ªáu dashboard",
      error: error.message
    });
  }
};

//! H√†m l·∫•y th·ªëng k√™ ƒë∆°n h√†ng
async function getOrderStats(storeId, startDate, endDate = new Date()) {
  try {
    console.log("üìà Getting order stats for store:", storeId);
    
    const matchStage = {
      storeId: storeId,
      createdAt: { $gte: startDate, $lte: endDate }
    };

    // ƒê·∫øm t·ªïng ƒë∆°n h√†ng
    const totalOrders = await Order.countDocuments(matchStage);
    
    // ƒê·∫øm ƒë∆°n ho√†n th√†nh
    const completedOrders = await Order.countDocuments({
      ...matchStage,
      status: "delivered"
    });
    
    // ƒê·∫øm ƒë∆°n ƒë√£ h·ªßy
    const cancelledOrders = await Order.countDocuments({
      ...matchStage,
      status: "cancelled"
    });

    // T√≠nh t·ªïng doanh thu t·ª´ c√°c ƒë∆°n ƒë√£ giao
    const revenueResult = await Order.aggregate([
      { 
        $match: { 
          storeId: storeId,
          createdAt: { $gte: startDate, $lte: endDate },
          status: "delivered" 
        } 
      },
      {
        $group: {
          _id: null,
          totalRevenue: { $sum: "$finalAmount" }
        }
      }
    ]);

    const totalRevenue = revenueResult.length > 0 ? revenueResult[0].totalRevenue : 0;

    // Th·ªëng k√™ theo status
    const statusStats = await Order.aggregate([
      { $match: matchStage },
      {
        $group: {
          _id: "$status",
          count: { $sum: 1 },
          revenue: { 
            $sum: { 
              $cond: [
                { $eq: ["$status", "delivered"] }, 
                "$finalAmount", 
                0 
              ] 
            } 
          }
        }
      }
    ]);

    const result = {
      total: totalOrders,
      completed: completedOrders,
      cancelled: cancelledOrders,
      totalRevenue: totalRevenue,
      byStatus: statusStats
    };

    console.log("üìà Order stats result:", result);
    return result;

  } catch (error) {
    console.error("‚ùå Error in getOrderStats:", error);
    return {
      total: 0,
      completed: 0,
      cancelled: 0,
      totalRevenue: 0,
      byStatus: []
    };
  }
}

//! H√†m l·∫•y th·ªëng k√™ doanh thu
async function getRevenueStats(storeId, startDate, endDate = new Date()) {
  try {
    console.log("üí∞ Getting revenue stats for store:", storeId);
    
    const matchStage = {
      storeId: storeId,
      createdAt: { $gte: startDate, $lte: endDate },
      status: "delivered"
    };

    // T·ªïng doanh thu
    const totalStats = await Order.aggregate([
      { $match: matchStage },
      {
        $group: {
          _id: null,
          total: { $sum: "$finalAmount" },
          orders: { $sum: 1 }
        }
      }
    ]);

    // Doanh thu theo ng√†y
    const dailyRevenue = await Order.aggregate([
      { $match: matchStage },
      {
        $group: {
          _id: {
            year: { $year: "$createdAt" },
            month: { $month: "$createdAt" },
            day: { $dayOfMonth: "$createdAt" }
          },
          revenue: { $sum: "$finalAmount" },
          orders: { $sum: 1 }
        }
      },
      { $sort: { "_id.year": 1, "_id.month": 1, "_id.day": 1 } }
    ]);

    // Doanh thu theo payment method
    const byPaymentMethod = await Order.aggregate([
      { $match: matchStage },
      {
        $group: {
          _id: "$paymentMethod",
          revenue: { $sum: "$finalAmount" },
          orders: { $sum: 1 }
        }
      }
    ]);

    const result = {
      total: totalStats.length > 0 ? totalStats[0].total : 0,
      daily: dailyRevenue,
      byPaymentMethod: byPaymentMethod
    };

    console.log("üí∞ Revenue result:", result);
    return result;

  } catch (error) {
    console.error("‚ùå Error in getRevenueStats:", error);
    return {
      total: 0,
      daily: [],
      byPaymentMethod: []
    };
  }
}

//! H√†m l·∫•y th·ªëng k√™ kh√°ch h√†ng
async function getCustomerStats(storeId, startDate, endDate = new Date()) {
  try {
    console.log("üë• Getting customer stats for store:", storeId);
    
    // Kh√°ch h√†ng m·ªõi trong k·ª≥
    const newCustomers = await Order.distinct("customerId", {
      storeId: storeId,
      createdAt: { $gte: startDate, $lte: endDate }
    });

    console.log("üë• New customers count:", newCustomers.length);

    // N·∫øu kh√¥ng c√≥ kh√°ch h√†ng m·ªõi, tr·∫£ v·ªÅ 0
    if (newCustomers.length === 0) {
      return {
        newCustomers: 0,
        returningCustomers: 0
      };
    }

    // Kh√°ch h√†ng c≈© (ƒë√£ mua tr∆∞·ªõc kho·∫£ng th·ªùi gian n√†y)
    const previousCustomers = await Order.distinct("customerId", {
      storeId: storeId,
      createdAt: { $lt: startDate }
    });

    const returningCustomers = newCustomers.filter(customerId => 
      previousCustomers.some(prevId => prevId.toString() === customerId.toString())
    ).length;

    return {
      newCustomers: newCustomers.length,
      returningCustomers: returningCustomers
    };

  } catch (error) {
    console.error("‚ùå Error in getCustomerStats:", error);
    return {
      newCustomers: 0,
      returningCustomers: 0
    };
  }
}

//! H√†m l·∫•y th·ªëng k√™ s·∫£n ph·∫©m
async function getProductStats(storeId, startDate, endDate = new Date()) {
  try {
    console.log("üì¶ Getting product stats for store:", storeId);
    
    const productStats = await Order.aggregate([
      {
        $match: {
          storeId: storeId,
          createdAt: { $gte: startDate, $lte: endDate },
          status: "delivered"
        }
      },
      { $unwind: "$items" },
      {
        $group: {
          _id: "$items.productId",
          totalSold: { $sum: "$items.quantity" },
          totalRevenue: { $sum: { $multiply: ["$items.price", "$items.quantity"] } }
        }
      },
      { $sort: { totalSold: -1 } },
      { $limit: 10 }
    ]);

    console.log("üì¶ Raw product stats:", productStats);

    // Populate product info
    const topProducts = await Promise.all(
      productStats.map(async (stat) => {
        try {
          const product = await Product.findById(stat._id).select("name images price category");
          return {
            _id: stat._id,
            name: product?.name || "S·∫£n ph·∫©m kh√¥ng x√°c ƒë·ªãnh",
            image: product?.images?.[0] || null,
            price: product?.price || 0,
            category: product?.category || "Kh√°c",
            quantity: stat.totalSold,
            revenue: stat.totalRevenue
          };
        } catch (error) {
          console.error("‚ùå Error populating product:", stat._id, error);
          return {
            _id: stat._id,
            name: "S·∫£n ph·∫©m kh√¥ng x√°c ƒë·ªãnh",
            image: null,
            price: 0,
            category: "Kh√°c",
            quantity: stat.totalSold,
            revenue: stat.totalRevenue
          };
        }
      })
    );

    const totalSold = productStats.reduce((sum, stat) => sum + stat.totalSold, 0);

    const result = {
      totalSold,
      topProducts
    };

    console.log("üì¶ Final product stats:", result);
    return result;

  } catch (error) {
    console.error("‚ùå Error in getProductStats:", error);
    return {
      totalSold: 0,
      topProducts: []
    };
  }
}

//! H√†m l·∫•y ƒë∆°n h√†ng g·∫ßn ƒë√¢y
async function getRecentOrders(storeId, limit = 10) {
  try {
    const orders = await Order.find({
      storeId: storeId
    })
    .sort({ createdAt: -1 })
    .limit(limit)
    .populate("customerId", "name email")
    .select("orderNumber status paymentStatus finalAmount createdAt customerInfo");

    return orders.map(order => ({
      _id: order._id,
      orderNumber: order.orderNumber,
      status: order.status,
      paymentStatus: order.paymentStatus,
      amount: order.finalAmount,
      customerName: order.customerInfo?.name || order.customerId?.name || "Kh√°ch h√†ng",
      createdAt: order.createdAt,
      type: "order"
    }));
  } catch (error) {
    console.error("‚ùå Error in getRecentOrders:", error);
    return [];
  }
}

//! Utility functions
function calculateStartDate(period, isPrevious = false) {
  const now = new Date();
  let days = 30;

  switch (period) {
    case "7d": days = 7; break;
    case "30d": days = 30; break;
    case "90d": days = 90; break;
    case "1y": days = 365; break;
  }

  if (isPrevious) {
    return new Date(now.setDate(now.getDate() - days * 2));
  }

  return new Date(now.setDate(now.getDate() - days));
}

//! Xu·∫•t b√°o c√°o dashboard ra Excel
export const exportDashboardReport = async (req, res) => {
    try {
      const managerId = req.user.userId || req.user._id;
      const { period = "30d", reportType = "overview" } = req.query;
  
      console.log("üìä Exporting dashboard report for manager:", managerId);
  
      // T√¨m c·ª≠a h√†ng c·ªßa manager
      const store = await Store.findOne({ manager: managerId });
      if (!store) {
        return res.status(404).json({
          success: false,
          message: "Kh√¥ng t√¨m th·∫•y c·ª≠a h√†ng cho manager n√†y"
        });
      }
  
      const startDate = calculateStartDate(period);
  
      // L·∫•y d·ªØ li·ªáu cho b√°o c√°o
      const [orderStats, revenueStats, productStats, recentOrders] = await Promise.all([
        getOrderStats(store._id, startDate),
        getRevenueStats(store._id, startDate),
        getProductStats(store._id, startDate),
        getRecentOrders(store._id, 50) // L·∫•y nhi·ªÅu h∆°n ƒë·ªÉ export
      ]);
  
      // T·∫°o workbook Excel
      const workbook = new ExcelJS.Workbook();
      
      // T·∫°o c√°c sheet kh√°c nhau t√πy theo reportType
      if (reportType === "overview" || reportType === "all") {
        await createOverviewSheet(workbook, store, orderStats, revenueStats, productStats, period);
      }
      
      if (reportType === "orders" || reportType === "all") {
        await createOrdersSheet(workbook, store, recentOrders, period);
      }
      
      if (reportType === "products" || reportType === "all") {
        await createProductsSheet(workbook, store, productStats, period);
      }
  
      // Thi·∫øt l·∫≠p headers cho response
      const fileName = `bao_cao_${store.storeCode}_${new Date().toISOString().split('T')[0]}.xlsx`;
      
      res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
      res.setHeader('Content-Disposition', `attachment; filename=${fileName}`);
  
      // Ghi file Excel v√† g·ª≠i v·ªÅ client
      await workbook.xlsx.write(res);
      res.end();
  
    } catch (error) {
      console.error("‚ùå Error exporting dashboard report:", error);
      res.status(500).json({
        success: false,
        message: "L·ªói server khi xu·∫•t b√°o c√°o",
        error: error.message
      });
    }
  };
  
  //! T·∫°o sheet t·ªïng quan
  async function createOverviewSheet(workbook, store, orderStats, revenueStats, productStats, period) {
    const worksheet = workbook.addWorksheet('T·ªïng Quan');
  
    // Ti√™u ƒë·ªÅ b√°o c√°o
    worksheet.mergeCells('A1:F1');
    worksheet.getCell('A1').value = `B√ÅO C√ÅO DASHBOARD - ${store.storeName}`;
    worksheet.getCell('A1').font = { size: 16, bold: true };
    worksheet.getCell('A1').alignment = { horizontal: 'center' };
  
    worksheet.mergeCells('A2:F2');
    worksheet.getCell('A2').value = `K·ª≥ b√°o c√°o: ${getPeriodLabel(period)} - Ng√†y xu·∫•t: ${new Date().toLocaleDateString('vi-VN')}`;
    worksheet.getCell('A2').font = { size: 12 };
    worksheet.getCell('A2').alignment = { horizontal: 'center' };
  
    // Th·ªëng k√™ ch√≠nh
    worksheet.mergeCells('A4:F4');
    worksheet.getCell('A4').value = 'CH·ªà S·ªê KINH DOANH CH√çNH';
    worksheet.getCell('A4').font = { size: 14, bold: true };
    worksheet.getCell('A4').fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE6E6FA' }
    };
  
    // Header cho b·∫£ng th·ªëng k√™
    worksheet.addRow(['Ch·ªâ s·ªë', 'Gi√° tr·ªã', 'ƒê∆°n v·ªã', 'TƒÉng tr∆∞·ªüng']);
    const headerRow = worksheet.getRow(5);
    headerRow.font = { bold: true };
    headerRow.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFF0F8FF' }
    };
  
    // D·ªØ li·ªáu th·ªëng k√™
    const statsData = [
      ['T·ªïng doanh thu', orderStats.totalRevenue, 'VND', '12.5%'],
      ['T·ªïng ƒë∆°n h√†ng', orderStats.total, 'ƒë∆°n', '8.3%'],
      ['ƒê∆°n ho√†n th√†nh', orderStats.completed, 'ƒë∆°n', '10.2%'],
      ['ƒê∆°n ƒë√£ h·ªßy', orderStats.cancelled, 'ƒë∆°n', '-2.1%'],
      ['Kh√°ch h√†ng m·ªõi', productStats.topProducts.length, 'kh√°ch', '15.7%'],
      ['S·∫£n ph·∫©m b√°n ra', productStats.totalSold, 's·∫£n ph·∫©m', '5.4%'],
      ['Gi√° tr·ªã ƒë∆°n trung b√¨nh', orderStats.total > 0 ? orderStats.totalRevenue / orderStats.total : 0, 'VND', '3.2%']
    ];
  
    statsData.forEach(([label, value, unit, growth]) => {
      const row = worksheet.addRow([
        label,
        typeof value === 'number' ? (unit === 'VND' ? formatExcelCurrency(value) : value) : value,
        unit,
        growth
      ]);
      
      // ƒê·ªãnh d·∫°ng s·ªë
      if (typeof value === 'number') {
        row.getCell(2).numFmt = unit === 'VND' ? '#,##0' : '0';
      }
    });
  
    // Ph√¢n b·ªï tr·∫°ng th√°i ƒë∆°n h√†ng
    worksheet.addRow([]);
    worksheet.mergeCells('A13:F13');
    worksheet.getCell('A13').value = 'PH√ÇN B·ªî TR·∫†NG TH√ÅI ƒê∆†N H√ÄNG';
    worksheet.getCell('A13').font = { size: 14, bold: true };
    worksheet.getCell('A13').fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE6E6FA' }
    };
  
    worksheet.addRow(['Tr·∫°ng th√°i', 'S·ªë l∆∞·ª£ng', 'T·ª∑ l·ªá', 'Doanh thu']);
    const statusHeaderRow = worksheet.getRow(14);
    statusHeaderRow.font = { bold: true };
    statusHeaderRow.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFF0F8FF' }
    };
  
    orderStats.byStatus.forEach(status => {
      const percentage = orderStats.total > 0 ? (status.count / orderStats.total * 100).toFixed(1) : 0;
      worksheet.addRow([
        getStatusLabel(status._id),
        status.count,
        `${percentage}%`,
        formatExcelCurrency(status.revenue || 0)
      ]);
    });
  
    // ƒêi·ªÅu ch·ªânh ƒë·ªô r·ªông c·ªôt
    worksheet.columns = [
      { width: 25 },
      { width: 15 },
      { width: 10 },
      { width: 12 },
      { width: 15 },
      { width: 15 }
    ];
  }
  
  //! T·∫°o sheet ƒë∆°n h√†ng
  async function createOrdersSheet(workbook, store, orders, period) {
    const worksheet = workbook.addWorksheet('ƒê∆°n H√†ng');
  
    worksheet.mergeCells('A1:H1');
    worksheet.getCell('A1').value = `DANH S√ÅCH ƒê∆†N H√ÄNG - ${store.storeName}`;
    worksheet.getCell('A1').font = { size: 16, bold: true };
    worksheet.getCell('A1').alignment = { horizontal: 'center' };
  
    // Header
    const headers = ['M√£ ƒë∆°n', 'Kh√°ch h√†ng', 'Tr·∫°ng th√°i', 'Thanh to√°n', 'S·ªë ti·ªÅn', 'Ng√†y t·∫°o', 'S·ªë SP', 'Ghi ch√∫'];
    worksheet.addRow(headers);
    
    const headerRow = worksheet.getRow(2);
    headerRow.font = { bold: true };
    headerRow.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE6E6FA' }
    };
  
    // D·ªØ li·ªáu ƒë∆°n h√†ng
    orders.forEach(order => {
      worksheet.addRow([
        order.orderNumber,
        order.customerName,
        getStatusLabel(order.status),
        getPaymentStatusLabel(order.paymentStatus),
        order.amount,
        new Date(order.createdAt).toLocaleDateString('vi-VN'),
        '', // S·ªë s·∫£n ph·∫©m - c√≥ th·ªÉ t√≠nh t·ª´ items n·∫øu c√≥
        '' // Ghi ch√∫
      ]);
    });
  
    // ƒê·ªãnh d·∫°ng c·ªôt s·ªë ti·ªÅn
    const amountCol = worksheet.getColumn(5);
    amountCol.numFmt = '#,##0';
  
    // ƒêi·ªÅu ch·ªânh ƒë·ªô r·ªông c·ªôt
    worksheet.columns = [
      { width: 15 },
      { width: 25 },
      { width: 15 },
      { width: 15 },
      { width: 15 },
      { width: 12 },
      { width: 10 },
      { width: 20 }
    ];
  }
  
  //! T·∫°o sheet s·∫£n ph·∫©m
  async function createProductsSheet(workbook, store, productStats, period) {
    const worksheet = workbook.addWorksheet('S·∫£n Ph·∫©m');
  
    worksheet.mergeCells('A1:E1');
    worksheet.getCell('A1').value = `TOP S·∫¢N PH·∫®M B√ÅN CH·∫†Y - ${store.storeName}`;
    worksheet.getCell('A1').font = { size: 16, bold: true };
    worksheet.getCell('A1').alignment = { horizontal: 'center' };
  
    // Header
    const headers = ['STT', 'T√™n s·∫£n ph·∫©m', 'S·ªë l∆∞·ª£ng b√°n', 'Doanh thu', 'Gi√° trung b√¨nh'];
    worksheet.addRow(headers);
    
    const headerRow = worksheet.getRow(2);
    headerRow.font = { bold: true };
    headerRow.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE6E6FA' }
    };
  
    // D·ªØ li·ªáu s·∫£n ph·∫©m
    productStats.topProducts.forEach((product, index) => {
      const avgPrice = product.quantity > 0 ? product.revenue / product.quantity : 0;
      worksheet.addRow([
        index + 1,
        product.name,
        product.quantity,
        product.revenue,
        avgPrice
      ]);
    });
  
    // T·ªïng k·∫øt
    worksheet.addRow([]);
    worksheet.addRow(['T·ªîNG C·ªòNG', '', productStats.totalSold, productStats.topProducts.reduce((sum, p) => sum + p.revenue, 0), '']);
  
    const totalRow = worksheet.getRow(worksheet.rowCount);
    totalRow.font = { bold: true };
    totalRow.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFF0F0F0' }
    };
  
    // ƒê·ªãnh d·∫°ng c·ªôt s·ªë
    worksheet.getColumn(3).numFmt = '#,##0';
    worksheet.getColumn(4).numFmt = '#,##0';
    worksheet.getColumn(5).numFmt = '#,##0';
  
    // ƒêi·ªÅu ch·ªânh ƒë·ªô r·ªông c·ªôt
    worksheet.columns = [
      { width: 8 },
      { width: 35 },
      { width: 15 },
      { width: 15 },
      { width: 15 }
    ];
  }
  
  //! Utility functions cho export
  function formatExcelCurrency(amount) {
    return Math.round(amount);
  }
  
  function getPeriodLabel(period) {
    const labels = {
      '7d': '7 ng√†y qua',
      '30d': '30 ng√†y qua', 
      '90d': '90 ng√†y qua',
      '1y': '1 nƒÉm qua'
    };
    return labels[period] || '30 ng√†y qua';
  }
  
  function getStatusLabel(status) {
    const labels = {
      'finding_driver': 'ƒêang t√¨m t√†i x·∫ø',
      'picking_up': 'ƒêang l·∫•y h√†ng',
      'delivering': 'ƒêang giao h√†ng',
      'delivered': 'ƒê√£ giao h√†ng',
      'cancelled': 'ƒê√£ h·ªßy'
    };
    return labels[status] || status;
  }
  
  function getPaymentStatusLabel(paymentStatus) {
    const labels = {
      'pending': 'Ch·ªù thanh to√°n',
      'paid': 'ƒê√£ thanh to√°n',
      'failed': 'Th·∫•t b·∫°i',
      'refunded': 'ƒê√£ ho√†n ti·ªÅn'
    };
    return labels[paymentStatus] || paymentStatus;
  }